# csp_inference.py
#
# AUTHOR
# ---------
# Jhonatan S. Oliveira
# oliveira@uregina.ca
# Department of Computer Science
# University of Regina
# Canada
#
#
# DESCRIPTION
# -----------
# Solving techniques try to find a solution for a given CSP.
# The implementations proposed here take into consideration a binary CSP generated by the model RB proposed in [1].
# Three methods are implemented for finding a CSP solution:
# 1) Backtrack Search
# 2) Backtrack Search with Forward Checking
# 1) Backtrack Search with Maintaining Arc Consistency
# The main algorithm for backtrack search follows the idea suggested in Figure 6.5 of [2].
#
#
# REFERENCES
# ----------
# [1] K. Xu and W. Li. Exact Phase Transitions in Random Constraint Satisfaction Problems. Journal of Artificial Intelligence Research, 12:93â€“103, 2000.
# [2] Russell, S. J., & Norvig, P. (2002). Artificial intelligence: a modern approach.

# Arc Reverse Implementation
# --------------------------
# In this part, Arc Reverse and all of its needed utility functions are implemented.



def revise(Di, Dj, Xi, Xj, constrain_Xi_Xj):
  """
  Description
  -----------
  Given a pair of nodes and the constrain between them, this function verifies if there are acceptable assignments.
  All the incompatible assignments are removed and the function returns True, meaning a revision in the CSP is needed.
  Otherwise, the function returns False.
  """
  revised = False
  for x in Di:
    is_all_incompatible = True
    for y in Dj:
      is_all_incompatible = is_all_incompatible and ((x,y) in constrain_Xi_Xj)
    if is_all_incompatible:
      Di.remove(x)
      revised = True
  return revised



def neighbors(node, arcs, except_node=None):
  """
  Description
  -----------
  Computes the neighbors of a given node considering all the incoming arcs.
  If an except node is given, then this node is not considered as neighbor.
  """
  neighbors = []
  for arc in arcs:
    if node in arc:
      for n in arc:
        if (n != node) and (n != except_node):
          if not n in neighbors:
            neighbors.append(n)
  return neighbors



def arc_consistency(variables, domains, constrains):
  """
  Description
  -----------
  Arc-consistency implementation following Algorithm AC-3 from Figure 6.3 in [1].
  The domain of each variable in a CSP is checked against the domain of the other variable in the same constrain.
  Whenever a domain value is not consistent with the correspondent one, they are removed.
  The arc_consistency function return True if the whole CSP is arc-consistent and False, otherwise.

  Example
  -------
  >>> variables = [0, 1, 2, 3, 4]
  >>> domains = {0: [0, 1, 2, 3], 1: [0, 1, 2, 3], 2: [0, 1, 2, 3], 3: [0, 1, 2, 3], 4: [0, 1, 2, 3]}
  >>> constrains = {(4, 3): [(3, 2), (2, 1), (3, 1), (1, 1), (2, 1), (2, 2), (2, 1), (2, 1), (0, 1), (1, 3), (0, 3), (1, 2)], (1, 3): [(3, 3), (0, 2), (3, 0), (0, 0), (2, 3), (1, 3), (2, 1), (1, 3), (0, 2), (0, 1), (1, 2), (0, 3)], (2, 0): [(1, 2), (2, 1), (2, 0), (3, 0), (3, 0), (0, 0), (3, 2), (3, 2), (0, 2), (1, 1), (1, 3), (1, 3)]}
  >>> arc_consistency(variables, domains, constrains)
  True

  Reference
  ---------
  [1] Russell, S. J., & Norvig, P. (2002). Artificial intelligence: a modern approach.
  """

  arcs = list(constrains.keys())

  if len(arcs) > 0:

    queue = [arcs[0]]

    while len(queue) > 0:
      Xi, Xj = queue.pop()
      if revise(domains[Xi], domains[Xj], Xi, Xj, constrains[(Xi,Xj)]):
        if len(domains[Xi]) == 0:
          return False
        neighbors_Xi = neighbors(Xi, arcs, Xj)
        for Xk in neighbors_Xi:
          if (Xk, Xi) in arcs:
            queue.append((Xk,Xi))
          else:
            queue.append((Xi,Xk))
  return True



# Backtrack Search Implementation
# --------------------------
# In this part, Backtrack Search and all of its needed utility functions are implemented.



def select_unassigned_variable(variables, domains, constrains, assignment, heuristic=None):
  """
  Description
  -----------
  This function returns a variable that was not assigned yet during backtrack search.
  Future works can implement heuristics here in order to assign the best variable in the current level.
  """
  non_assigned_vars = [v for v in variables if not v in assignment.keys()]
  if len(non_assigned_vars) > 0:
    return non_assigned_vars[0]
  else:
    return None



def order_domain_values(var, assignment, variables, domains, constrains):
  """
  Description
  -----------
  This function returns a value ordering for a given assigned variable.
  Future works can implement heuristics here in order to find best orderings for the current layer.
  """
  return domains[var]



def inference(var, value, variables, domains, constrains, assignment, inf_type = None):
  """
  Description
  -----------
  Inference during backtrack search can enforce consistency and filter assigned variables when needed.
  Notice that heuristics for inference can be applied.
  Two heuristics are currently implemented:
  1) Forward checking (FC)
  2) Maintaining Arc Consistency (MAC)
  """
  new_assignments = {}
  if inf_type == "FC":
    result = arc_consistency(variables, domains, constrains)
    if not result:
      new_assignments = "Failure"
  elif inf_type == "MAC":
    # Find variables that are unassigned and neighbor of var
    unassg_vars = []
    sub_constrains = {}
    for (var1,var2) in constrains.keys():
      if var in (var1,var2):
        other_var = None
        if var1 == var:
          other_var = var1
        else:
          other_var = var2
        if not other_var in assignment.keys():
          unassg_vars.append(other_var)
          sub_constrains[(var1,var2)] = constrains[(var1,var2)]
    # Call AC with the sub constrains and variables
    result = arc_consistency(unassg_vars, domains, sub_constrains)
    if not result:
      new_assignments = "Failure"


  return new_assignments




def is_consistent(var, value, assignment, constrains):
  """
  Description
  -----------
  Before a new assignment is saved in backtrack search, this function test for consistency.
  If the variable/value pair is inconsistent with any constrain, False is returned.
  Otherwise, True is returned.
  """
  is_consistent = True
  for var1 in assignment:
    if (var1,var) in constrains:
      if (assignment[var1],value) in constrains[(var1,var)]:
        is_consistent = False
    elif (var,var1) in constrains:
      if (value,assignment[var1]) in constrains[(var,var1)]:
        is_consistent = False
  return is_consistent





def backtrack(assignment, variables, domains, constrains, inf_type=None):
  """
  Description
  -----------
  Algorithm for backtrack search implemented as suggested in Figure 6.5 of [1].
  Backtrack search tries to find a solution for a given CSP following a depth first approach.
  That is, at each level (layer) a new variable with a value is tried.
  Whenever an inconsistency is found, the algorithm backtracks and tried a new assignment.

  Example
  -------
  >>> variables = [0, 1, 2, 3, 4]
  >>> domains = {0: [0, 1, 2, 3], 1: [0, 1, 2, 3], 2: [0, 1, 2, 3], 3: [0, 1, 2, 3], 4: [0, 1, 2, 3]}
  >>> constrains = {(4, 3): [(3, 2), (2, 1), (3, 1), (1, 1), (2, 1), (2, 2), (2, 1), (2, 1), (0, 1), (1, 3), (0, 3), (1, 2)], (1, 3): [(3, 3), (0, 2), (3, 0), (0, 0), (2, 3), (1, 3), (2, 1), (1, 3), (0, 2), (0, 1), (1, 2), (0, 3)], (2, 0): [(1, 2), (2, 1), (2, 0), (3, 0), (3, 0), (0, 0), (3, 2), (3, 2), (0, 2), (1, 1), (1, 3), (1, 3)]}
  >>> backtrack({}, variables, domains, constrains)

  Reference
  ---------
  [1] Russell, S. J., & Norvig, P. (2002). Artificial intelligence: a modern approach.
  """
  # If assignment is complete
  if len(assignment) == len(variables):
    return assignment
  # Select unassigned variable
  var = select_unassigned_variable(variables, domains, constrains, assignment)
  for value in order_domain_values(var, assignment, variables, domains, constrains):
    inference_assignments = None
    # If value is consistent with assignment
    if is_consistent(var, value, assignment, constrains):
      # Add new assignment
      assignment[var] = value
      # Make a copy of domains, in case the branch is backtracked
      _domain = domains.copy()
      # Perform inference (Forward Checking or MAC)
      inference_assignments = inference(var, value, variables, _domain, constrains, assignment, inf_type = inf_type)
      if inference_assignments != "Failure":
        # Add inference to assignment
        for v in inference_assignments:
          assignment[v] = inference_assignments[v]
        # Recursive call for next layer in the backtrack search tree
        result = backtrack(assignment, variables, domains, constrains)
        if result != "Failure":
          return result
  return "Failure"



